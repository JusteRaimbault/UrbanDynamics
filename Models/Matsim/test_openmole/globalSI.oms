val x1 = Val[Double]
val x2 = Val[Double]

// works with 
//val x3 = Val[String]
val x4 = Val[Int]

val y1 = Val[Double]
val y2 = Val[Double]

/* Expected values of first order (SI) and total order (STI) sensitivity indices.
 *
 * - y1, x1: SI1 = 4/5, STI1 = 4/5
 * - y1, x2: SI2 = 1/5, STI2 = 1/5
 * - y2, x1: SI1 = (9 / 4) * (12 / 42) ~= 0.643, 
 *           STI1 = (7.0 / 36.0) / (40.0 / 144.0) = 0.7
 * - y2, x2: SI2 = 12 / 42 ~= 0.286, 
 *           STI2 = (13.0 / 144.0) / (40.0 / 144.0) ~= 0.325
 */

val model = ScalaTask("""val y1 = x1 + 0.5 * x2 + x3.toDouble + x4.toDouble;
                         val y2 = x1 + 0.5 * x2 + x1 * x2""") set (
  inputs += (x1, x2, x3,x4),
  outputs += (y1, y2)
)

val sen = SensitivitySaltelli( 
  evaluation = model,
  sample = 100,
  inputs = Seq(x1 in (0.0, 1.0), x2 in (0.0, 1.0), x3 in Seq("0.0","0.5","1.0"), x4 in Seq(0,1)),
  outputs = Seq(y1, y2)
) hook display // hook (workDirectory / "sensitivity")
//hook display

sen //hook SaltelliHook(sen, workDirectory / "sensitivity")


/*val mySeed = Val[Int]

val mean = ScalaTask("""
  def sumTerms(a: Array[Array[Double]], b: Array[Array[Double]]): Array[Array[Double]] = 
    (a zip b).map{case (ai, bi) => 
      (ai zip bi).map {case (aij, bij) => 
        aij + bij
      }
    }
  val reps = fosi.size 
  val fosiMean = fosi.reduce(sumTerms).map{_.map{_/reps}}
  val tosiMean = tosi.reduce(sumTerms).map{_.map{_/reps}}
""") set (
  inputs += (fosi.toArray, tosi.toArray),
  outputs += (fosiMean, tosiMean)
)

val rep = Replication(
  evaluation = sen,
  replications = 1,
  seed = mySeed,
  aggregation = mean
)*/
